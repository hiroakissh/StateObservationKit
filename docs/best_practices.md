# ベストプラクティス

StateObservationKit で状態駆動設計を実践する際の推奨事項をまとめます。各指針は、網羅性とテスタビリティを高めるための経験則です。

| 指針 | 説明 |
| --- | --- |
| `default` 禁止 | すべての状態遷移を列挙し、将来の追加時にコンパイルエラーで漏れを検知します。 |
| View は `switch` で全状態を描画 | StateMachine 導入の意義を保ち、UI と状態の対応関係を明確にします。 |
| 副作用は UseCase に集約 | I/O や非同期処理を StateMachine から切り離し、テストしやすい分割を維持します。 |
| StateMachine はドメイン単位で作成 | 小さな責務単位で再利用性を高め、複数の画面で同じロジックを共有します。 |
| UseCase はテストしやすく | Repository を依存性注入 (DI) で差し替え、統合テストとユニットテストを両立させます。 |

## テスト戦略
- Reducer ロジックは同期テストで確認し、副作用はモックで隔離します。
- イベントシーケンスを網羅し、状態遷移の完結性を保証するテストケースを構築します。
- Swift Concurrency を伴う処理では `async` テストを活用し、メインアクターやカスタムアクターの順序保証を検証します。

## 運用上のヒント
- 状態の定義と遷移図をドキュメント化し、チーム全体で共有します。
- 新しい状態やイベントを追加する際は、既存 View の `switch` がコンパイルエラーになることを確認し、描画漏れを防ぎます。
- 監視対象が多い場合は、StateMachine の出力を細分化して ViewModel 層で集約するなど、更新頻度に応じた最適化を検討します。
